import U from "path";
import { ESLintUtils as ne, ASTUtils as D } from "@typescript-eslint/utils";
import { minimatch as M } from "minimatch";
import le from "natural-compare-lite";
import { builtinModules as ie } from "module";
let O = ne.RuleCreator(
  (a) => `https://eslint-plugin-perfectionist.azat.io/rules/${a}`
), x = (a, l) => {
  for (let s = 0, o = a.length; s < o; s++) {
    let u = a[s];
    if (l.group === u || Array.isArray(u) && typeof l.group == "string" && u.includes(l.group))
      return s;
  }
  return a.length;
}, w = (a) => {
  let [l, s] = a;
  return s - l;
}, v = (a) => a > 0;
var i = /* @__PURE__ */ ((a) => (a.alphabetical = "alphabetical", a["line-length"] = "line-length", a.natural = "natural", a))(i || {}), f = /* @__PURE__ */ ((a) => (a.desc = "desc", a.asc = "asc", a))(f || {});
let R = (a) => {
  let l, s = (u) => {
    !l && a.flat().includes(u) && (l = u);
  };
  return {
    getGroup: () => l ?? "unknown",
    setCustomGroups: (u, r) => {
      if (u)
        for (let [e, t] of Object.entries(u))
          Array.isArray(t) && t.some(
            (n) => M(r, n, {
              nocomment: !0
            })
          ) && s(e), typeof t == "string" && M(r, t, {
            nocomment: !0
          }) && s(e);
    },
    defineGroup: s
  };
}, A = (a, l, s) => {
  var e, t;
  if ((e = l.dependencies) != null && e.includes(a.name))
    return -1;
  if ((t = a.dependencies) != null && t.includes(l.name))
    return 1;
  let o = s.order === "asc" ? 1 : -1, u, r = (n) => s["ignore-case"] ? n.toLowerCase() : n;
  return s.type === i.alphabetical ? u = (n, c) => r(n.name).localeCompare(r(c.name)) : s.type === i.natural ? u = (n, c) => le(r(n.name), r(c.name)) : u = (n, c) => n.size - c.size, o * u(a, l);
}, S = (a, l) => [...a].sort((s, o) => A(s, o, l)), pe = (a, l) => {
  let s = l.getTokenAfter(a, {
    filter: ({ value: o, type: u }) => !(u === "Punctuator" && [",", ";"].includes(o)),
    includeComments: !0
  });
  return ((s == null ? void 0 : s.type) === "Block" || (s == null ? void 0 : s.type) === "Line") && a.loc.end.line === s.loc.end.line ? s : null;
}, oe = (a, l) => Array.isArray(a) && a.some(
  (s) => M(l.trim(), s, {
    nocomment: !0
  })
) || typeof a == "string" && M(l.trim(), a, {
  nocomment: !0
}) || a === !0, _ = (a, l) => {
  let [s, o] = l.getTokensBefore(a, {
    filter: ({ value: u, type: r }) => !(r === "Punctuator" && [",", ";"].includes(u)),
    includeComments: !0,
    count: 2
  });
  return ((o == null ? void 0 : o.type) === "Block" || (o == null ? void 0 : o.type) === "Line") && a.loc.start.line - o.loc.end.line <= 1 && (s == null ? void 0 : s.loc.end.line) !== o.loc.start.line ? o : null;
}, T = (a, l, s) => {
  var t;
  let o = a.range.at(0), u = a.range.at(1), r = l.text.slice(o, u);
  if (D.isParenthesized(a, l)) {
    let n = l.getTokenBefore(
      a,
      D.isOpeningParenToken
    ), c = l.getTokenAfter(
      a,
      D.isClosingParenToken
    );
    o = n.range.at(0), u = c.range.at(1);
  }
  let e = _(a, l);
  if (r.endsWith(";") || r.endsWith(",")) {
    let n = l.getTokensAfter(a, {
      includeComments: !0,
      count: 2
    });
    a.loc.start.line === ((t = n.at(1)) == null ? void 0 : t.loc.start.line) && (u -= 1);
  }
  return e && !oe(
    (s == null ? void 0 : s.partitionComment) ?? !1,
    e.value
  ) && (o = e.range.at(0)), [o, u];
}, C = (a, l, s, o, u) => {
  var t, n;
  let r = [], e = ((t = l.at(0)) == null ? void 0 : t.node.loc.start.line) === ((n = l.at(-1)) == null ? void 0 : n.node.loc.end.line);
  for (let c = 0, d = l.length; c < d; c++) {
    let { node: m } = l.at(c);
    r.push(
      a.replaceTextRange(
        T(m, o, u),
        o.text.slice(
          ...T(s.at(c).node, o, u)
        )
      )
    );
    let g = pe(s.at(c).node, o);
    if (g && !e) {
      let y = [
        o.getTokenBefore(g).range.at(1),
        g.range.at(1)
      ];
      r.push(a.replaceTextRange(y, ""));
      let h = o.getTokenAfter(m);
      r.push(
        a.insertTextAfter(
          (h == null ? void 0 : h.loc.end.line) === m.loc.end.line ? h : m,
          o.text.slice(...y)
        )
      );
    }
  }
  return r;
}, j = (a = {}, l) => Object.assign(l, a), k = (a, l) => {
  if (a.length > 1)
    for (let s = 1; s < a.length; s++) {
      let o = a.at(s - 1), u = a.at(s);
      o && u && l(o, u, s - 1);
    }
};
const V = "sort-svelte-attributes", ue = O({
  name: V,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Svelte attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedSvelteAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => U.extname(a.getFilename()) !== ".svelte" ? {} : {
    SvelteStartTag: (l) => {
      if (l.attributes.length > 1) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), o = a.getSourceCode(), u = l.attributes.reduce(
          (r, e) => {
            if (e.type === "SvelteSpreadAttribute")
              return r.push([]), r;
            let t, { getGroup: n, defineGroup: c, setCustomGroups: d } = R(
              s.groups
            );
            return e.key.type === "SvelteSpecialDirectiveKey" ? t = o.text.slice(...e.key.range) : typeof e.key.name == "string" ? { name: t } = e.key : t = o.text.slice(...e.key.range), d(s["custom-groups"], t), e.type === "SvelteShorthandAttribute" && (c("svelte-shorthand"), c("shorthand")), (!("value" in e) || Array.isArray(e.value) && !e.value.at(0)) && c("shorthand"), e.loc.start.line !== e.loc.end.line && c("multiline"), r.at(-1).push({
              size: w(e.range),
              node: e,
              group: n(),
              name: t
            }), r;
          },
          [[]]
        );
        for (let r of u)
          k(r, (e, t) => {
            let n = x(s.groups, e), c = x(s.groups, t);
            (n > c || n === c && v(A(e, t, s))) && a.report({
              messageId: "unexpectedSvelteAttributesOrder",
              data: {
                left: e.name,
                right: t.name
              },
              node: t.node,
              fix: (d) => {
                let m = {};
                for (let p of r) {
                  let y = x(s.groups, p);
                  y in m ? m[y] = S(
                    [...m[y], p],
                    s
                  ) : m[y] = [p];
                }
                let g = [];
                for (let p of Object.keys(m).sort())
                  g.push(...S(m[p], s));
                return C(d, r, g, o);
              }
            });
          });
      }
    }
  }
}), W = "sort-astro-attributes", ce = O({
  name: W,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Astro attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedAstroAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  // @ts-ignore
  create: (a) => U.extname(a.getFilename()) !== ".astro" ? {} : {
    JSXElement: (l) => {
      let { attributes: s } = l.openingElement;
      if (s.length > 1) {
        let o = j(a.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), u = a.getSourceCode(), r = s.reduce(
          (e, t) => {
            if (t.type === "JSXSpreadAttribute")
              return e.push([]), e;
            let n = typeof t.name.name == "string" ? t.name.name : u.text.slice(...t.name.range), { getGroup: c, defineGroup: d, setCustomGroups: m } = R(
              o.groups
            );
            return m(o["custom-groups"], n), t.type === "AstroShorthandAttribute" && (d("astro-shorthand"), d("shorthand")), t.value === null && d("shorthand"), t.loc.start.line !== t.loc.end.line && d("multiline"), e.at(-1).push({
              size: w(t.range),
              node: t,
              group: c(),
              name: n
            }), e;
          },
          [[]]
        );
        for (let e of r)
          k(e, (t, n) => {
            let c = x(o.groups, t), d = x(o.groups, n);
            (c > d || c === d && v(A(t, n, o))) && a.report({
              messageId: "unexpectedAstroAttributesOrder",
              data: {
                left: t.name,
                right: n.name
              },
              node: n.node,
              fix: (m) => {
                let g = {};
                for (let y of e) {
                  let h = x(o.groups, y);
                  h in g ? g[h] = S(
                    [...g[h], y],
                    o
                  ) : g[h] = [y];
                }
                let p = [];
                for (let y of Object.keys(g).sort())
                  p.push(...S(g[y], o));
                return C(m, e, p, u);
              }
            });
          });
      }
    }
  }
});
let I = (a) => a.replaceAll(/\s\s+/g, " ").trim();
const J = "sort-array-includes", de = O({
  name: J,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted arrays before include method"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "spread-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedArrayIncludesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    MemberExpression: (l) => {
      if ((l.object.type === "ArrayExpression" || l.object.type === "NewExpression") && l.property.type === "Identifier" && l.property.name === "includes") {
        let s = l.object.type === "ArrayExpression" ? l.object.elements : l.object.arguments;
        if (s.length > 1) {
          let o = j(a.options.at(0), {
            type: i.alphabetical,
            order: f.asc,
            "ignore-case": !1,
            "spread-last": !1
          }), u = a.getSourceCode(), r = s.reduce(
            (e, t) => (t !== null && e.at(0).push({
              name: t.type === "Literal" ? `${t.value}` : u.text.slice(...t.range),
              size: w(t.range),
              type: t.type,
              node: t
            }), e),
            [[], []]
          ).flat();
          k(r, (e, t) => {
            let n;
            o["spread-last"] && e.node.type === "Literal" && t.node.type === "SpreadElement" ? n = !1 : o["spread-last"] && e.node.type === "SpreadElement" && t.node.type === "Literal" ? n = !0 : n = v(A(e, t, o)), n && a.report({
              messageId: "unexpectedArrayIncludesOrder",
              data: {
                left: I(e.name),
                right: I(t.name)
              },
              node: t.node,
              fix: (c) => {
                let d = S(r, o);
                if (o["spread-last"])
                  for (let m = 0, g = d.length; m < g; m++)
                    d.at(m).node.type === "SpreadElement" && d.push(d.splice(m, 1).at(0));
                return C(c, r, d, u);
              }
            });
          });
        }
      }
    }
  })
}), X = "sort-vue-attributes", fe = O({
  name: X,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Vue attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedVueAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => {
    if (U.extname(a.getFilename()) !== ".vue")
      return {};
    if (!("defineTemplateBodyVisitor" in a.parserServices))
      return {};
    let { defineTemplateBodyVisitor: l } = a.parserServices;
    return l({
      VStartTag: (s) => {
        if (s.attributes.length > 1) {
          let o = j(a.options.at(0), {
            type: i.alphabetical,
            order: f.asc,
            "ignore-case": !1,
            "custom-groups": {},
            groups: []
          }), u = a.getSourceCode(), r = s.attributes.reduce(
            (e, t) => {
              if (t.key.type === "VDirectiveKey" && t.key.name.rawName === "bind")
                return e.push([]), e;
              let n, { getGroup: c, defineGroup: d, setCustomGroups: m } = R(
                o.groups
              );
              return typeof t.key.name == "string" && t.key.type !== "VDirectiveKey" ? n = t.key.rawName : n = u.text.slice(...t.key.range), m(o["custom-groups"], n), t.value === null && d("shorthand"), t.loc.start.line !== t.loc.end.line && d("multiline"), e.at(-1).push({
                size: w(t.range),
                node: t,
                group: c(),
                name: n
              }), e;
            },
            [[]]
          );
          for (let e of r)
            k(e, (t, n) => {
              let c = x(o.groups, t), d = x(o.groups, n);
              (c > d || c === d && v(A(t, n, o))) && a.report({
                messageId: "unexpectedVueAttributesOrder",
                data: {
                  left: t.name,
                  right: n.name
                },
                node: n.node,
                fix: (m) => {
                  let g = {};
                  for (let y of e) {
                    let h = x(o.groups, y);
                    h in g ? g[h] = S(
                      [...g[h], y],
                      o
                    ) : g[h] = [y];
                  }
                  let p = [];
                  for (let y of Object.keys(g).sort())
                    p.push(...S(g[y], o));
                  return C(m, e, p, u);
                }
              });
            });
        }
      }
    });
  }
}), K = "sort-named-exports", ge = O({
  name: K,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    ExportNamedDeclaration: (l) => {
      if (l.specifiers.length > 1) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc
        }), o = a.getSourceCode(), u = l.specifiers.map((r) => ({
          size: w(r.range),
          name: r.local.name,
          node: r
        }));
        k(u, (r, e) => {
          v(A(r, e, s)) && a.report({
            messageId: "unexpectedNamedExportsOrder",
            data: {
              left: r.name,
              right: e.name
            },
            node: e.node,
            fix: (t) => C(t, u, S(u, s), o)
          });
        });
      }
    }
  })
}), q = "sort-named-imports", ye = O({
  name: q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    ImportDeclaration: (l) => {
      let s = l.specifiers.filter(
        ({ type: o }) => o === "ImportSpecifier"
      );
      if (s.length > 1) {
        let o = j(a.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc
        }), u = a.getSourceCode(), r = s.map((e) => ({
          size: w(e.range),
          name: e.local.name,
          node: e
        }));
        k(r, (e, t) => {
          v(A(e, t, o)) && a.report({
            messageId: "unexpectedNamedImportsOrder",
            data: {
              left: e.name,
              right: t.name
            },
            node: t.node,
            fix: (n) => C(n, r, S(r, o), u)
          });
        });
      }
    }
  })
}), F = "sort-object-types", me = O({
  name: F,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted object types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    TSTypeLiteral: (l) => {
      if (l.members.length > 1) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc,
          "custom-groups": {},
          groups: []
        }), o = a.getSourceCode(), u = l.members.map((r) => {
          var y, h;
          let e, t = o.text.slice(r.range.at(0), r.range.at(1)), { getGroup: n, defineGroup: c, setCustomGroups: d } = R(
            s.groups
          ), m = (N) => N.replace(/(,|;)$/, "");
          if (r.type === "TSPropertySignature")
            r.key.type === "Identifier" ? { name: e } = r.key : r.key.type === "Literal" ? e = `${r.key.value}` : e = o.text.slice(
              r.range.at(0),
              (y = r.typeAnnotation) == null ? void 0 : y.range.at(0)
            );
          else if (r.type === "TSIndexSignature") {
            let N = ((h = r.typeAnnotation) == null ? void 0 : h.range.at(0)) ?? r.range.at(1);
            e = m(o.text.slice(r.range.at(0), N));
          } else
            e = m(
              o.text.slice(r.range.at(0), r.range.at(1))
            );
          d(s["custom-groups"], e), r.loc.start.line !== r.loc.end.line && c("multiline");
          let p = t.endsWith(";") || t.endsWith(",") ? 1 : 0;
          return {
            size: w(r.range) - p,
            group: n(),
            node: r,
            name: e
          };
        });
        k(u, (r, e) => {
          let t = x(s.groups, r), n = x(s.groups, e);
          (t > n || t === n && v(A(r, e, s))) && a.report({
            messageId: "unexpectedObjectTypesOrder",
            data: {
              left: I(r.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (c) => {
              let d = {};
              for (let g of u) {
                let p = x(s.groups, g);
                p in d ? d[p] = S(
                  [...d[p], g],
                  s
                ) : d[p] = [g];
              }
              let m = [];
              for (let g of Object.keys(d).sort())
                m.push(...S(d[g], s));
              return C(c, u, m, o);
            }
          });
        });
      }
    }
  })
}), H = "sort-union-types", he = O({
  name: H,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted union types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "nullable-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedUnionTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    TSUnionType: (l) => {
      let s = a.getSourceCode(), o = j(a.options.at(0), {
        type: i.alphabetical,
        "nullable-last": !1,
        "ignore-case": !1,
        order: f.asc
      }), u = l.types.map((r) => ({
        group: r.type === "TSNullKeyword" || r.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
        name: s.text.slice(...r.range),
        size: w(r.range),
        node: r
      }));
      k(u, (r, e) => {
        let t = v(A(r, e, o));
        o["nullable-last"] && (r.group === "nullable" && e.group === "unknown" ? t = !0 : r.group === "unknown" && e.group === "nullable" && (t = !1)), t && a.report({
          messageId: "unexpectedUnionTypesOrder",
          data: {
            left: I(r.name),
            right: I(e.name)
          },
          node: e.node,
          fix: (n) => {
            let c = [];
            if (o["nullable-last"]) {
              let d = [], m = u.filter((g) => g.group === "nullable" ? (d.push(g), !1) : !0);
              c = [
                ...S(m, o),
                ...S(d, o)
              ];
            } else
              c = S(u, o);
            return C(n, u, c, s);
          }
        });
      });
    }
  })
}), Q = "sort-interfaces", be = O({
  name: Q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted interface properties"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedInterfacePropertiesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    TSInterfaceDeclaration: (l) => {
      if (l.body.body.length > 1) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc,
          "ignore-pattern": [],
          "custom-groups": {},
          groups: []
        });
        if (!s["ignore-pattern"].some(
          (o) => M(l.id.name, o, {
            nocomment: !0
          })
        )) {
          let o = a.getSourceCode(), u = l.body.body.reduce(
            (r, e) => {
              var m, g, p;
              if (e.type === "TSCallSignatureDeclaration")
                return r.push([]), r;
              let t, { getGroup: n, defineGroup: c, setCustomGroups: d } = R(
                s.groups
              );
              if (e.type === "TSPropertySignature")
                if (e.key.type === "Identifier")
                  ({ name: t } = e.key);
                else if (e.key.type === "Literal")
                  t = `${e.key.value}`;
                else {
                  let y = ((m = e.typeAnnotation) == null ? void 0 : m.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
                  t = o.text.slice(e.range.at(0), y);
                }
              else if (e.type === "TSIndexSignature") {
                let y = ((g = e.typeAnnotation) == null ? void 0 : g.range.at(0)) ?? e.range.at(1);
                t = o.text.slice(e.range.at(0), y);
              } else {
                let y = ((p = e.returnType) == null ? void 0 : p.range.at(0)) ?? e.range.at(1);
                t = o.text.slice(e.range.at(0), y);
              }
              return d(s["custom-groups"], t), e.loc.start.line !== e.loc.end.line && c("multiline"), r.at(-1).push({
                size: w(e.range),
                group: n(),
                node: e,
                name: t
              }), r;
            },
            [[]]
          );
          for (let r of u)
            k(r, (e, t) => {
              let n = x(s.groups, e), c = x(s.groups, t);
              (n > c || n === c && v(A(e, t, s))) && a.report({
                messageId: "unexpectedInterfacePropertiesOrder",
                data: {
                  left: I(e.name),
                  right: I(t.name)
                },
                node: t.node,
                fix: (d) => {
                  let m = {};
                  for (let p of r) {
                    let y = x(s.groups, p);
                    y in m ? m[y] = S(
                      [...m[y], p],
                      s
                    ) : m[y] = [p];
                  }
                  let g = [];
                  for (let p of Object.keys(m).sort())
                    g.push(...S(m[p], s));
                  return C(d, r, g, o);
                }
              });
            });
        }
      }
    }
  })
}), Y = "sort-jsx-props", xe = O({
  name: Y,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted JSX props"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          groups: {
            type: "array"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedJSXPropsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => [".svelte", ".astro", ".vue"].includes(
    U.extname(a.getFilename())
  ) ? {} : {
    JSXElement: (l) => {
      if (l.openingElement.attributes.length > 1) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc,
          "custom-groups": {},
          groups: []
        }), o = a.getSourceCode(), u = l.openingElement.attributes.reduce(
          (r, e) => {
            if (e.type === "JSXSpreadAttribute")
              return r.push([]), r;
            let t = e.name.type === "JSXNamespacedName" ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name, { getGroup: n, defineGroup: c, setCustomGroups: d } = R(
              s.groups
            );
            d(s["custom-groups"], t), e.value === null && c("shorthand"), e.loc.start.line !== e.loc.end.line && c("multiline");
            let m = {
              size: w(e.range),
              group: n(),
              node: e,
              name: t
            };
            return r.at(-1).push(m), r;
          },
          [[]]
        );
        for (let r of u)
          k(r, (e, t) => {
            let n = x(s.groups, e), c = x(s.groups, t);
            (n > c || n === c && v(A(e, t, s))) && a.report({
              messageId: "unexpectedJSXPropsOrder",
              data: {
                left: e.name,
                right: t.name
              },
              node: t.node,
              fix: (d) => {
                let m = {};
                for (let p of r) {
                  let y = x(s.groups, p);
                  y in m ? m[y] = S(
                    [...m[y], p],
                    s
                  ) : m[y] = [p];
                }
                let g = [];
                for (let p of Object.keys(m).sort())
                  g.push(...S(m[p], s));
                return C(d, r, g, o);
              }
            });
          });
      }
    }
  }
}), Z = "sort-exports", Ee = O({
  name: Z,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => {
    let l = j(a.options.at(0), {
      type: i.alphabetical,
      order: f.asc,
      "ignore-case": !1
    }), s = [[]], o = (u) => {
      u.type === "ExportAllDeclaration" && u.exported === null ? s.push([]) : s.at(-1).push({
        size: w(u.range),
        name: u.source.value,
        node: u
      });
    };
    return {
      ExportAllDeclaration: o,
      ExportNamedDeclaration: (u) => {
        u.source !== null && o(u);
      },
      "Program:exit": () => {
        let u = a.getSourceCode();
        for (let r of s)
          k(r, (e, t) => {
            v(A(e, t, l)) && a.report({
              messageId: "unexpectedExportsOrder",
              data: {
                left: e.name,
                right: t.name
              },
              node: t.node,
              fix: (n) => C(n, r, S(r, l), u)
            });
          });
      }
    };
  }
}), ee = "sort-imports", Se = O({
  name: ee,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object",
            properties: {
              type: {
                type: "object"
              },
              value: {
                type: "object"
              }
            },
            additionalProperties: !1
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "internal-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          "newlines-between": {
            enum: [
              "ignore",
              "always",
              "never"
              /* never */
            ],
            default: "always",
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"',
      missedSpacingBetweenImports: 'Missed spacing between "{{left}}" and "{{right}}" imports',
      extraSpacingBetweenImports: 'Extra spacing between "{{left}}" and "{{right}}" imports'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => {
    let l = j(a.options.at(0), {
      "newlines-between": "always",
      "custom-groups": { type: {}, value: {} },
      "internal-pattern": ["~/**"],
      type: i.alphabetical,
      order: f.asc,
      "ignore-case": !1,
      groups: []
    }), s = a.getSourceCode(), o = [], u = (t) => t.type === "ImportDeclaration" && t.specifiers.length === 0, r = (t) => {
      let n = (b) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
        (E) => b.endsWith(E)
      ), c = (b) => [
        "./index.d.js",
        "./index.d.ts",
        "./index.js",
        "./index.ts",
        "./index",
        "./",
        "."
      ].includes(b), d = (b) => b.indexOf("..") === 0, m = (b) => b.indexOf("./") === 0, { getGroup: g, defineGroup: p, setCustomGroups: y } = R(l.groups), h = (b) => l["internal-pattern"].length && l["internal-pattern"].some(
        (E) => M(b.source.value, E, {
          nocomment: !0
        })
      ), N = (b) => {
        let E = [
          "bun",
          "bun:ffi",
          "bun:jsc",
          "bun:sqlite",
          "bun:test",
          "bun:wrap",
          "detect-libc",
          "undici",
          "ws"
        ];
        return ie.includes(
          b.startsWith("node:") ? b.split("node:")[1] : b
        ) || E.includes(b);
      };
      return t.importKind === "type" && (t.type === "ImportDeclaration" && (y(l["custom-groups"].type, t.source.value), N(t.source.value) && p("builtin-type"), h(t) && p("internal-type"), c(t.source.value) && p("index-type"), d(t.source.value) && p("parent-type"), m(t.source.value) && p("sibling-type")), p("external-type"), p("type")), t.type === "ImportDeclaration" && (y(l["custom-groups"].value, t.source.value), N(t.source.value) && p("builtin"), h(t) && p("internal"), n(t.source.value) && p("style"), u(t) && p("side-effect"), c(t.source.value) && p("index"), d(t.source.value) && p("parent"), m(t.source.value) && p("sibling"), p("external")), g();
    }, e = (t) => {
      let n;
      t.type === "ImportDeclaration" ? n = t.source.value : t.moduleReference.type === "TSExternalModuleReference" && t.moduleReference.expression.type === "Literal" ? n = `${t.moduleReference.expression.value}` : n = s.text.slice(...t.moduleReference.range), o.push({
        size: w(t.range),
        group: r(t),
        name: n,
        node: t
      });
    };
    return {
      TSImportEqualsDeclaration: e,
      ImportDeclaration: e,
      "Program:exit": () => {
        var m;
        let t = (g, p) => !!s.getTokensBetween(
          g.node,
          _(p.node, s) || p.node,
          {
            includeComments: !0
          }
        ).length, n = (g, p) => s.lines.slice(
          g.node.loc.end.line,
          p.node.loc.start.line - 1
        ).filter((h) => !h.trim().length).length, c = (g, p) => {
          let y = [], h = {};
          for (let b of p) {
            let E = x(l.groups, b);
            E in h ? h[E] = S(
              [...h[E], b],
              l
            ) : h[E] = [b];
          }
          let N = Object.keys(h).sort().reduce(
            (b, E) => [
              ...b,
              ...h[E]
            ],
            []
          );
          for (let b = 0, E = N.length; b < E; b++) {
            let L = N.at(b);
            if (y.push(
              g.replaceTextRange(
                T(p.at(b).node, s),
                s.text.slice(...T(L.node, s))
              )
            ), l["newlines-between"] !== "ignore") {
              let G = N.at(b + 1);
              if (G) {
                let P = n(
                  p.at(b),
                  p.at(b + 1)
                );
                (l["newlines-between"] === "always" && x(l.groups, L) === x(l.groups, G) && P !== 0 || l["newlines-between"] === "never" && P > 0) && y.push(
                  g.removeRange([
                    T(p.at(b).node, s).at(1),
                    T(p.at(b + 1).node, s).at(0) - 1
                  ])
                ), l["newlines-between"] === "always" && x(l.groups, L) !== x(l.groups, G) && P > 1 && y.push(
                  g.replaceTextRange(
                    [
                      T(p.at(b).node, s).at(1),
                      T(p.at(b + 1).node, s).at(
                        0
                      ) - 1
                    ],
                    `
`
                  )
                ), l["newlines-between"] === "always" && x(l.groups, L) !== x(l.groups, G) && P === 0 && y.push(
                  g.insertTextAfterRange(
                    T(p.at(b).node, s),
                    `
`
                  )
                );
              }
            }
          }
          return y;
        }, d = [[]];
        for (let g of o) {
          let p = (m = d.at(-1)) == null ? void 0 : m.at(-1);
          p && t(p, g) ? d.push([g]) : d.at(-1).push(g);
        }
        for (let g of d)
          k(g, (p, y) => {
            let h = x(l.groups, p), N = x(l.groups, y), b = n(p, y);
            !(u(p.node) && u(y.node)) && !t(p, y) && (h > N || h === N && v(A(p, y, l))) && a.report({
              messageId: "unexpectedImportsOrder",
              data: {
                left: p.name,
                right: y.name
              },
              node: y.node,
              fix: (E) => c(E, g)
            }), l["newlines-between"] === "never" && b > 0 && a.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: p.name,
                right: y.name
              },
              node: y.node,
              fix: (E) => c(E, g)
            }), l["newlines-between"] === "always" && (h < N && b === 0 ? a.report({
              messageId: "missedSpacingBetweenImports",
              data: {
                left: p.name,
                right: y.name
              },
              node: y.node,
              fix: (E) => c(E, g)
            }) : (b > 1 || h === N && b > 0) && a.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: p.name,
                right: y.name
              },
              node: y.node,
              fix: (E) => c(E, g)
            }));
          });
      }
    };
  }
}), te = "sort-objects", Ne = O({
  name: te,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted objects"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          "partition-by-comment": {
            type: ["boolean", "string", "array"],
            default: !1
          },
          "styled-components": {
            type: "boolean",
            default: !0
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => {
    let l = (s) => {
      if (s.properties.length > 1) {
        let o = j(a.options.at(0), {
          "partition-by-comment": !1,
          type: i.alphabetical,
          "styled-components": !0,
          "ignore-case": !1,
          order: f.asc,
          "custom-groups": {},
          groups: []
        }), u = (n) => n.type === "Identifier" && n.name === "styled", r = (n) => n !== void 0 && n.type === "CallExpression" && (n.callee.type === "MemberExpression" && u(n.callee.object) || n.callee.type === "CallExpression" && u(n.callee.callee));
        if (!o["styled-components"] && (r(s.parent) || s.parent.type === "ArrowFunctionExpression" && r(s.parent.parent)))
          return;
        let e = a.getSourceCode(), t = (n) => n.reduce(
          (c, d) => {
            if (d.type === "SpreadElement" || d.type === "RestElement")
              return c.push([]), c;
            let m = _(d, e);
            o["partition-by-comment"] && m && oe(
              o["partition-by-comment"],
              m.value
            ) && c.push([]);
            let g, p = "ignore", y = [], { getGroup: h, setCustomGroups: N } = R(o.groups);
            d.key.type === "Identifier" ? { name: g } = d.key : d.key.type === "Literal" ? g = `${d.key.value}` : g = e.text.slice(...d.key.range), d.value.type === "AssignmentPattern" && ((L) => {
              L.right.type === "Identifier" && y.push(L.right.name);
              let G = (P) => {
                let $ = [];
                switch (P.type) {
                  case "ArrowFunctionExpression":
                    $.push(P.body);
                    break;
                  case "ConditionalExpression":
                    $.push(P.consequent, P.alternate);
                    break;
                  case "LogicalExpression":
                  case "BinaryExpression":
                    $.push(P.left, P.right);
                    break;
                  case "CallExpression":
                    $.push(...P.arguments);
                    break;
                }
                $.forEach((B) => {
                  B.type === "Identifier" && y.push(B.name), (B.type === "BinaryExpression" || B.type === "ConditionalExpression") && G(B);
                });
              };
              switch (L.right.type) {
                case "ArrowFunctionExpression":
                case "ConditionalExpression":
                case "LogicalExpression":
                case "BinaryExpression":
                case "CallExpression":
                  G(L.right);
                  break;
              }
            })(d.value), N(o["custom-groups"], g);
            let b = {
              size: w(d.range),
              group: h(),
              dependencies: y,
              node: d,
              position: p,
              name: g
            };
            return c.at(-1).push(b), c;
          },
          [[]]
        );
        for (let n of t(s.properties))
          k(n, (c, d) => {
            let m = x(o.groups, c), g = x(o.groups, d);
            if (m > g || m === g && v(A(c, d, o))) {
              let p = (y) => {
                let h = {};
                for (let b of n) {
                  let E = x(o.groups, b);
                  E in h ? h[E] = S(
                    [...h[E], b],
                    o
                  ) : h[E] = [b];
                }
                let N = [];
                for (let b of Object.keys(h).sort())
                  N.push(...S(h[b], o));
                return C(y, n, N, e, {
                  partitionComment: o["partition-by-comment"]
                });
              };
              a.report({
                messageId: "unexpectedObjectsOrder",
                data: {
                  left: I(c.name),
                  right: I(d.name)
                },
                node: d.node,
                fix: p
              });
            }
          });
      }
    };
    return {
      ObjectExpression: l,
      ObjectPattern: l
    };
  }
}), re = "sort-classes", Ae = O({
  name: re,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted classes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedClassesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    ClassBody: (l) => {
      if (l.body.length > 1) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1,
          groups: ["property", "constructor", "method", "unknown"]
        }), o = a.getSourceCode(), u = l.body.map((r) => {
          var d;
          let e, { getGroup: t, defineGroup: n } = R(s.groups);
          r.type === "StaticBlock" ? e = "static" : r.type === "TSIndexSignature" ? e = o.text.slice(
            r.range.at(0),
            ((d = r.typeAnnotation) == null ? void 0 : d.range.at(0)) ?? r.range.at(1)
          ) : r.key.type === "Identifier" ? { name: e } = r.key : e = o.text.slice(...r.key.range);
          let c = e.startsWith("_") || e.startsWith("#");
          if (r.type === "MethodDefinition") {
            r.kind === "constructor" && n("constructor");
            let m = r.accessibility === "private" || c, g = r.static;
            m && g && n("static-private-method"), m && n("private-method"), g && n("static-method"), r.kind === "get" && n("get-method"), r.kind === "set" && n("set-method"), n("method");
          } else
            r.type === "TSIndexSignature" ? n("index-signature") : r.type === "PropertyDefinition" && ((r.accessibility === "private" || c) && n("private-property"), r.static && n("static-property"), n("property"));
          return {
            size: w(r.range),
            group: t(),
            node: r,
            name: e
          };
        });
        k(u, (r, e) => {
          let t = x(s.groups, r), n = x(s.groups, e);
          r.name !== e.name && (t > n || t === n && v(A(r, e, s))) && a.report({
            messageId: "unexpectedClassesOrder",
            data: {
              left: I(r.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (c) => {
              let d = [], m = u.reduce(
                (p, y) => {
                  let h = x(s.groups, y);
                  return h in p ? p[h] = S(
                    [...p[h], y],
                    s
                  ) : p[h] = [y], p;
                },
                {}
              ), g = Object.keys(m).sort().reduce(
                (p, y) => [
                  ...p,
                  ...m[y]
                ],
                []
              );
              for (let p = 0, y = g.length; p < y; p++)
                d.push(
                  c.replaceTextRange(
                    T(u.at(p).node, o),
                    o.text.slice(
                      ...T(g.at(p).node, o)
                    )
                  )
                );
              return d;
            }
          });
        });
      }
    }
  })
}), se = "sort-enums", Ie = O({
  name: se,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted TypeScript enums"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedEnumsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    TSEnumDeclaration: (l) => {
      if (l.members.length > 1 && l.members.every(({ initializer: s }) => s)) {
        let s = j(a.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1
        }), o = a.getSourceCode(), u = l.members.map((r) => ({
          name: r.id.type === "Literal" ? `${r.id.value}` : `${o.text.slice(...r.id.range)}`,
          size: w(r.range),
          node: r
        }));
        k(u, (r, e) => {
          v(A(r, e, s)) && a.report({
            messageId: "unexpectedEnumsOrder",
            data: {
              left: I(r.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (t) => C(t, u, S(u, s), o)
          });
        });
      }
    }
  })
}), ae = "sort-maps", Oe = O({
  name: ae,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Map elements"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedMapElementsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (a) => ({
    NewExpression: (l) => {
      if (l.callee.type === "Identifier" && l.callee.name === "Map" && l.arguments.length && l.arguments[0].type === "ArrayExpression") {
        let [{ elements: s }] = l.arguments;
        if (s.length > 1) {
          let o = j(a.options.at(0), {
            type: i.alphabetical,
            "ignore-case": !1,
            order: f.asc
          }), u = a.getSourceCode(), r = s.reduce(
            (e, t) => (t === null || t.type === "SpreadElement" ? e.push([]) : e.at(-1).push(t), e),
            [[]]
          );
          for (let e of r) {
            let t = e.map((n) => {
              let c;
              if (n.type === "ArrayExpression") {
                let [d] = n.elements;
                d ? d.type === "Literal" ? c = d.raw : c = u.text.slice(...d.range) : c = `${d}`;
              } else
                c = u.text.slice(...n.range);
              return {
                size: w(n.range),
                node: n,
                name: c
              };
            });
            k(t, (n, c) => {
              v(A(n, c, o)) && a.report({
                messageId: "unexpectedMapElementsOrder",
                data: {
                  left: I(n.name),
                  right: I(c.name)
                },
                node: c.node,
                fix: (d) => C(d, t, S(t, o), u)
              });
            });
          }
        }
      }
    }
  })
}), we = "eslint-plugin-perfectionist";
let z = (a) => {
  let l = {
    [ee]: [
      "error",
      {
        groups: [
          "type",
          ["builtin", "external"],
          "internal-type",
          "internal",
          ["parent-type", "sibling-type", "index-type"],
          ["parent", "sibling", "index"],
          "object",
          "unknown"
        ],
        "custom-groups": {
          value: {},
          type: {}
        },
        "newlines-between": "always",
        "internal-pattern": ["~/**"]
      }
    ],
    [re]: [
      "error",
      {
        groups: [
          "index-signature",
          "static-property",
          "private-property",
          "property",
          "constructor",
          "static-method",
          "private-method",
          "method",
          ["get-method", "set-method"],
          "unknown"
        ]
      }
    ],
    [te]: [
      "error",
      {
        "partition-by-comment": !1
      }
    ],
    [J]: [
      "error",
      {
        "spread-last": !0
      }
    ],
    [V]: ["error"],
    [W]: ["error"],
    [X]: ["error"],
    [K]: ["error"],
    [q]: ["error"],
    [F]: ["error"],
    [H]: ["error"],
    [Q]: ["error"],
    [Y]: ["error"],
    [Z]: ["error"],
    [se]: ["error"],
    [ae]: ["error"]
  };
  return {
    rules: Object.fromEntries(
      Object.entries(l).map(([s, [o, u = {}]]) => [
        `perfectionist/${s}`,
        [o, Object.assign(u, a)]
      ])
    ),
    plugins: ["perfectionist"]
  };
};
const Te = {
  rules: {
    [J]: de,
    [W]: ce,
    [re]: Ae,
    [se]: Ie,
    [Z]: Ee,
    [ee]: Se,
    [Q]: be,
    [Y]: xe,
    [ae]: Oe,
    [K]: ge,
    [q]: ye,
    [F]: me,
    [te]: Ne,
    [V]: ue,
    [H]: he,
    [X]: fe
  },
  configs: {
    "recommended-alphabetical": z({
      type: i.alphabetical,
      order: f.asc,
      "ignore-case": !1
    }),
    "recommended-natural": z({
      type: i.natural,
      order: f.asc,
      "ignore-case": !1
    }),
    "recommended-line-length": z({
      type: i["line-length"],
      order: f.desc
    })
  },
  name: we
};
export {
  Te as default
};
